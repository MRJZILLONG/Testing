//{"name":"SecurityFirewall","version":"1.1.50","created":"2018-02-06T13:39:53.065Z"}
webpackJsonp([0],{0:function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ruleAppliedToaster = exports.profileChangeToaster = exports.netDetectedToaster = exports.default = undefined;\n\nvar _ractive = __webpack_require__(1);\n\nvar _ractive2 = _interopRequireDefault(_ractive);\n\nvar _nitroApi = __webpack_require__(2);\n\nvar _nitroApi2 = _interopRequireDefault(_nitroApi);\n\nvar _d = __webpack_require__(16);\n\nvar _d2 = _interopRequireDefault(_d);\n\nvar _moment = __webpack_require__(17);\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _momentDurationFormat = __webpack_require__(123);\n\nvar _momentDurationFormat2 = _interopRequireDefault(_momentDurationFormat);\n\nvar _lodash = __webpack_require__(124);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _netDetectedToaster = __webpack_require__(125);\n\nvar _netDetectedToaster2 = _interopRequireDefault(_netDetectedToaster);\n\nvar _profileChangeToaster = __webpack_require__(130);\n\nvar _profileChangeToaster2 = _interopRequireDefault(_profileChangeToaster);\n\nvar _ruleAppliedToaster = __webpack_require__(131);\n\nvar _ruleAppliedToaster2 = _interopRequireDefault(_ruleAppliedToaster);\n\nvar _index = __webpack_require__(132);\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Toasters\n\n// Common libs - do not edit,\n// otherwiser depency indexes will get messed up\nexports.default = _index2.default;\nexports.netDetectedToaster = _netDetectedToaster2.default;\nexports.profileChangeToaster = _profileChangeToaster2.default;\nexports.ruleAppliedToaster = _ruleAppliedToaster2.default;\n\n// App itself\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.js\n// module id = 0\n// module chunks = 0\n//# sourceURL=webpack:///./index.js?")},125:function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _profileSwitchToaster = __webpack_require__(126);\n\nvar _profileSwitchToaster2 = _interopRequireDefault(_profileSwitchToaster);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _profileSwitchToaster2.default.extend({\n\tdata: function data() {\n\t\treturn {\n\t\t\ttoasterType: 'netDetected',\n\t\t\ttextId: 'firewall.toasters.netDetected.text'\n\t\t};\n\t}\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/netDetectedToaster.js\n// module id = 125\n// module chunks = 0\n//# sourceURL=webpack:///./app/netDetectedToaster.js?")},126:function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _ractive = __webpack_require__(1);\n\nvar _ractive2 = _interopRequireDefault(_ractive);\n\nvar _nitroApi = __webpack_require__(2);\n\nvar _nitroApi2 = _interopRequireDefault(_nitroApi);\n\nvar _constants = __webpack_require__(127);\n\nvar _index = __webpack_require__(128);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _profileSwitchToaster = __webpack_require__(129);\n\nvar _profileSwitchToaster2 = _interopRequireDefault(_profileSwitchToaster);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar nls = _ractive2.default.localization.nls; /**\n                                               * Common conde for the netDetected and profileChange toasters.\n                                               * To distinguish between these two it gets the toasterType param\n                                               * as well as the textId param to get the proper translation.\n                                               */\n\nexports.default = _ractive2.default.extend({\n\ttemplate: _profileSwitchToaster2.default,\n\tcss: _index2.default,\n\tasyncLoad: true,\n\tdata: function data() {\n\t\treturn {\n\t\t\tMODES: _constants.MODES,\n\t\t\ttoasterType: null,\n\t\t\ttextId: null,\n\t\t\ttext: null,\n\t\t\tnls: nls,\n\t\t\tprofile: null,\n\t\t\tssid: null,\n\t\t\tswitchDisabled: true,\n\t\t\tloading: false,\n\t\t\twindowWidth: 360,\n\t\t\ttriggerScanOnClose: true\n\t\t};\n\t},\n\toninit: function oninit() {\n\t\tvar _this = this;\n\n\t\tthis.log = _nitroApi2.default.loggerManager.createLogger('firewall.toasters.' + this.get('toasterType'));\n\n\t\tthis.toasterCompo = this.findComponent('Toaster');\n\t\tthis.toasterCompo.gaTrack = _nitroApi2.default.track;\n\n\t\t// TODO: params after || are backwards compatibily\n\t\tvar ssid = this.get('params.networkName') || this.get('params.ssid');\n\t\tvar profile = this.get('params.mode') || this.get('params.profile');\n\n\t\tthis.log.info('oninit; ssid: ' + ssid + ', profile: ' + profile);\n\n\t\tthis.set({\n\t\t\tprofile: profile,\n\t\t\tssid: ssid,\n\t\t\tswitchDisabled: false\n\t\t});\n\n\t\tthis.set('switchProps.value', profile);\n\t\tthis.set('switchProps.disabled', false);\n\n\t\tthis.on('Toaster.close', function () {\n\t\t\tthis.log.info('closing');\n\t\t\tthis.closeWindow(null);\n\t\t});\n\n\t\twindow.addEventListener('beforeunload', function () {\n\t\t\tif (_this.get('triggerScanOnClose')) {\n\t\t\t\t_nitroApi2.default.request('asw.hns.start', {\n\t\t\t\t\t'scan_type': 'quick',\n\t\t\t\t\t'start_type': 'router_changed'\n\t\t\t\t});\n\t\t\t}\n\t\t}, false);\n\n\t\tthis.on('toggleSwitch', function (event) {\n\t\t\tvar _this2 = this;\n\n\t\t\t_nitroApi2.default.track.event('Toaster', 'Click', 'Switch');\n\n\t\t\tthis.log.info('switching profile');\n\n\t\t\tevent.original.preventDefault();\n\n\t\t\tthis.set('switchDisabled', true);\n\n\t\t\tvar newProfile = this.get('profile') === _constants.MODES.private ? _constants.MODES.public : _constants.MODES.private;\n\n\t\t\t_nitroApi2.default.request('app.firewall.SetNetworkProfile', {\n\t\t\t\t// TODO: params after || are backwards compatibily\n\t\t\t\trouterAddress: this.get('params.routerMac') || this.get('params.routerAddress'),\n\t\t\t\tadapterName: this.get('params.adapterDesc') || this.get('params.adapterName'),\n\t\t\t\tmode: newProfile\n\t\t\t}).then(function () {\n\t\t\t\t_this2.log.info('profile successfully set');\n\n\t\t\t\t_this2.set({\n\t\t\t\t\tprofile: newProfile,\n\t\t\t\t\tswitchDisabled: false\n\t\t\t\t});\n\t\t\t}).catch(function (e) {\n\t\t\t\t_this2.log.error('changing profile failed', e);\n\t\t\t});\n\t\t});\n\n\t\tthis.on('scanNetwork', function (event) {\n\t\t\tvar _this3 = this;\n\n\t\t\tevent.original.stopPropagation();\n\n\t\t\t_nitroApi2.default.track.event('Toaster', 'Click', 'ScanNetwork');\n\n\t\t\tthis.log.info('opening Wi-Fi Inspector');\n\n\t\t\t_nitroApi2.default.request('app.windowManager.ShowMainWindow', {\n\t\t\t\troute: 'SecurityNetwork'\n\t\t\t}).then(function () {\n\t\t\t\t_this3.set('triggerScanOnClose', false);\n\t\t\t\t_this3.closeWindow(_nitroApi2.default.MainWindow.CLOSE_REASONS.navigateToOtherWindow);\n\t\t\t}).catch(function (error) {\n\t\t\t\t_this3.log.error('opening Wi-Fi Inspector failed', error);\n\t\t\t});\n\t\t});\n\t},\n\n\tonrender: function onrender() {\n\t\tvar _this4 = this;\n\n\t\t// If it's called synchronously it causes bug AV-15612.\n\t\t// So far it does that only in firewall\n\t\t// with the english firewall.toasters.text.profile translation\n\t\t// and it's length. If it's shorter or longer, it's fine.\n\t\t// I've spent to much time solving that without success..\n\t\t// giving up, this workaround needs to be enough.\n\t\t// If it became more often, more digging in the Toaster compo would be needed.\n\t\twindow.setTimeout(function () {\n\t\t\t_this4.setText();\n\n\t\t\t_this4.ready();\n\t\t}, 0);\n\t},\n\t_goToFirewall: function _goToFirewall() {\n\t\tvar _this5 = this;\n\n\t\t_nitroApi2.default.track.event('Toaster', 'Click', 'GoToFirewall');\n\n\t\tthis.log.info('opening firewall');\n\n\t\t_nitroApi2.default.request('app.windowManager.ShowMainWindow', {\n\t\t\troute: 'SecurityFirewall'\n\t\t}).then(function () {\n\t\t\t_this5.closeWindow(_nitroApi2.default.MainWindow.CLOSE_REASONS.navigateToOtherWindow);\n\t\t}).catch(function (error) {\n\t\t\t_this5.log.error('opening firewall failed', error);\n\t\t});\n\t},\n\tcloseWindow: function closeWindow() {\n\t\tvar reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n\t\tif (reason !== null) {\n\t\t\t_nitroApi2.default.MainWindow.close({\n\t\t\t\treason: reason\n\t\t\t});\n\t\t} else {\n\t\t\t_nitroApi2.default.MainWindow.close();\n\t\t}\n\t},\n\tsetText: function setText() {\n\t\tvar _this6 = this;\n\n\t\tvar ssid = this.get('ssid');\n\n\t\tvar title = nls(this.get('textId'));\n\t\tvar network = '<div class=\"toaster__item-name g-margin-bottom--15\">' + ssid + '<span style=\"font-weight: normal\">.</span></div>';\n\n\t\tif (!ssid || ssid.length === 0) {\n\t\t\ttitle = title + '.';\n\t\t\tnetwork = '<div class=\"g-margin-bottom--15\"></div>';\n\t\t}\n\n\t\tif (this.get('profile')) {\n\t\t\tthis.set('text', title + network + nls('firewall.toasters.text.profile'));\n\n\t\t\tvar link = this.find('a[href=goToFirewall]');\n\n\t\t\tif (link) {\n\t\t\t\t// Because we don't want to mess links in the translation too much\n\t\t\t\t// we add everything here - classes and functionality\n\t\t\t\tlink.className += 'a';\n\t\t\t\tlink.addEventListener('click', function () {\n\t\t\t\t\t_this6._goToFirewall();\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthis.set('text', title + network + nls('firewall.toasters.text.firewallDisabled'));\n\t\t}\n\t}\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/components/profileSwitchToaster.js\n// module id = 126\n// module chunks = 0\n//# sourceURL=webpack:///./app/components/profileSwitchToaster.js?")},127:function(module,exports){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * List of all possible statuses of firewall.\n * @type {Object}\n */\nvar STATUSES = {\n\tinvalid: 'invalid',\n\tinactive: 'inactive',\n\twating: 'wating',\n\trunning: 'running',\n\tnotInstalled: 'not_installed' // should not even get here with this state\n};\n\n/**\n * List of all possible network modes.\n * @type {Object}\n */\nvar MODES = {\n\tprivate: 'private',\n\tpublic: 'public'\n};\n\nexports.STATUSES = STATUSES;\nexports.MODES = MODES;\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/constants.js\n// module id = 127\n// module chunks = 0\n//# sourceURL=webpack:///./app/constants.js?")},128:function(module,exports){eval('module.exports = ".frw_main {\\n  padding-bottom: 15px;\\n}\\n.frw_half {\\n  width: 50%;\\n  float: left;\\n  position: relative;\\n}\\n.frw_crumbs {\\n  display: block;\\n}\\n.frw_network {\\n  padding: 15px 0 15px 5px;\\n  clear: both;\\n  margin-bottom: 5px;\\n  width: 100%;\\n  position: relative;\\n}\\n.frw_network__wrap {\\n  margin-top: 5px;\\n  padding: 15px 0;\\n}\\n.frw_network__icon {\\n  display: inline-block;\\n  vertical-align: middle;\\n  font-size: 50px;\\n}\\n.frw_network__details {\\n  display: inline-block;\\n  vertical-align: top;\\n  padding: 8px 15 0;\\n  max-width: 75%;\\n}\\n.frw_label {\\n  display: inline-block;\\n  min-width: 40px;\\n}\\n.frw_toggle {\\n  position: absolute;\\n  right: 5px;\\n  top: 25px;\\n  transition: transform 0.2s linear;\\n}\\n.frw_toggle .icon {\\n  line-height: 110%;\\n}\\n.frw_toggle.frw_-is-expanded {\\n  transform: rotate(180deg);\\n}\\n.frw_connected,\\n.frw_mode {\\n  padding: 0 30px;\\n  display: block;\\n  vertical-align: middle;\\n  float: left;\\n}\\n.frw_mode {\\n  padding-top: 10px;\\n  padding-bottom: 10px;\\n}\\n.frw_connected {\\n  border-right: solid 1px #ddd;\\n}\\n.frw_connected__status {\\n  position: absolute;\\n  top: 0;\\n  bottom: 0;\\n  left: 0;\\n  width: 5px;\\n}\\n.frw_links {\\n  text-align: right;\\n}\\n.frw_links a,\\n.frw_links button {\\n  margin: 0 10px;\\n}\\n.frw_links a:last-child,\\n.frw_links button:last-child {\\n  margin-right: 0;\\n}\\n.frw_apps {\\n  margin-bottom: 5px;\\n}\\n.frw_app {\\n  width: 14.66%;\\n  margin: 1%;\\n  float: left;\\n  padding: 15px 3px 10px;\\n  text-align: center;\\n  position: relative;\\n  cursor: pointer;\\n  border-radius: 3px;\\n}\\n.frw_app__icon {\\n  font-size: 32px;\\n  margin-bottom: 8px;\\n}\\n.frw_app__blocked {\\n  position: absolute;\\n  top: 38px;\\n  left: 50%;\\n  margin-left: 5px;\\n  font-size: 18px;\\n  background-color: #fff;\\n  border-radius: 50px;\\n  width: 20px;\\n  height: 20px;\\n  line-height: 20px;\\n  text-align: center;\\n}\\n.frw_switch {\\n  margin-top: 8px;\\n  margin-bottom: 12px;\\n  padding-left: 8px;\\n}\\n.frw_switch .switch__label {\\n  min-width: 120px;\\n}\\n.frw_empty {\\n  width: 100%;\\n  padding: 20px;\\n  text-align: center;\\n  clear: both;\\n}\\n[dir=rtl] .frw_links {\\n  text-align: left;\\n}\\n[dir=rtl] a,\\n[dir=rtl] button,\\n[dir=rtl]:last-child {\\n  margin-right: 10px;\\n  margin-left: 0;\\n}\\n[dir=rtl] h3.frw_half {\\n  left: 15px;\\n}\\n[dir=rtl] .frw_toggle {\\n  right: auto;\\n  left: 5px;\\n}\\n"\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/index.styl\n// module id = 128\n// module chunks = 0\n//# sourceURL=webpack:///./app/index.styl?')},129:function(module,exports){eval('module.exports={"v":3,"t":[{"t":7,"e":"Toaster","a":{"loading":[{"t":2,"r":"loading"}],"windowWidth":[{"t":2,"r":"windowWidth"}],"windowHeight":[{"t":2,"r":"windowHeight"}],"customContent":"true","text":[{"t":2,"r":"text"}],"autoResize":"true"},"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":"switch__wrap frw_switch"},"f":[{"t":7,"e":"Switch","a":{"txt":["{left:\'",{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.toaster.mode.private\\")"}},"\',right:\'",{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.toaster.mode.public\\")"}},"\'}"],"checked":[{"t":2,"r":"profile"}],"values":["{left:\'",{"t":2,"r":"MODES.private"},"\',right:\'",{"t":2,"r":"MODES.public"},"\'}"],"isCheckbox":"false","disabled":[{"t":2,"r":"switchDisabled"}],"cssCls":[{"t":4,"f":["-waiting"],"n":50,"r":"switchDisabled"}],"preventToggle":"true"},"v":{"domClick":"toggleSwitch"}}]}],"n":50,"r":"profile"},{"t":7,"e":"button","a":{"class":"toaster__btn btn -small"},"v":{"click":"scanNetwork"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.toasters.scanNetwork\\")"}}]}]}]};\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/components/profileSwitchToaster.html\n// module id = 129\n// module chunks = 0\n//# sourceURL=webpack:///./app/components/profileSwitchToaster.html?')},130:function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _profileSwitchToaster = __webpack_require__(126);\n\nvar _profileSwitchToaster2 = _interopRequireDefault(_profileSwitchToaster);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _profileSwitchToaster2.default.extend({\n\tdata: function data() {\n\t\treturn {\n\t\t\ttoasterType: 'profileChange',\n\t\t\ttextId: 'firewall.toasters.profileChange.text'\n\t\t};\n\t}\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/profileChangeToaster.js\n// module id = 130\n// module chunks = 0\n//# sourceURL=webpack:///./app/profileChangeToaster.js?")},131:function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _ractive = __webpack_require__(1);\n\nvar _ractive2 = _interopRequireDefault(_ractive);\n\nvar _nitroApi = __webpack_require__(2);\n\nvar _nitroApi2 = _interopRequireDefault(_nitroApi);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar log = _nitroApi2.default.loggerManager.createLogger('firewall.toasters.ruleApplied');\n\nvar nls = _ractive2.default.localization.nls;\n\nexports.default = _ractive2.default.components.Toaster.extend({\n\twindowClose: _nitroApi2.default.MainWindow.close.bind(_nitroApi2.default.MainWindow),\n\n\t// notifying the service manually when loaded (this.ready)\n\tasyncLoad: true,\n\n\tgaTrack: _nitroApi2.default.track,\n\n\tdata: function data() {\n\t\treturn {\n\t\t\ttext: null,\n\t\t\tbuttonLabel: nls('firewall.toasters.ruleApplied.buttonLabel'),\n\t\t\tbuttonLabelGA: 'Details',\n\t\t\tautoResize: true\n\t\t};\n\t},\n\toninit: function oninit() {\n\t\tthis._super();\n\n\t\tvar appName = this.get('params.appName');\n\t\tvar appGuid = this.get('params.appGuid');\n\t\tvar action = this.get('params.action'); // deny or allow\n\n\t\tlog.info('oninit; appName: ' + appName + ', appGuid: ' + appGuid + ', action: ' + action);\n\n\t\tthis.on('doAction', function () {\n\t\t\tlog.info('opening app rules');\n\n\t\t\t_nitroApi2.default.request('av.command', 'show_fw_app_rules:' + appGuid).then(function () {\n\t\t\t\t_nitroApi2.default.MainWindow.close({\n\t\t\t\t\treason: _nitroApi2.default.MainWindow.CLOSE_REASONS.navigateToOtherWindow\n\t\t\t\t});\n\t\t\t}).catch(function (error) {\n\t\t\t\tlog.error('opening app rules failed', error);\n\t\t\t});\n\t\t});\n\n\t\tthis.on('doAreaAction', function () {\n\t\t\tlog.info('opening firewall');\n\n\t\t\t_nitroApi2.default.request('app.windowManager.ShowMainWindow', {\n\t\t\t\troute: 'SecurityFirewall'\n\t\t\t}).then(function () {\n\t\t\t\t_nitroApi2.default.MainWindow.close({\n\t\t\t\t\treason: _nitroApi2.default.MainWindow.CLOSE_REASONS.navigateToOtherWindow\n\t\t\t\t});\n\t\t\t}).catch(function (error) {\n\t\t\t\tlog.error('opening firewall failed', error);\n\t\t\t});\n\t\t});\n\n\t\tif (appName && appGuid && action) {\n\t\t\tthis.set('text', nls('firewall.toasters.ruleApplied.text.' + action, appName));\n\n\t\t\tthis.set('loading', false);\n\n\t\t\tthis.ready();\n\t\t} else {\n\t\t\tlog.warn('no app name, guid or action');\n\n\t\t\t_nitroApi2.default.MainWindow.close({\n\t\t\t\treason: _nitroApi2.default.MainWindow.CLOSE_REASONS.error\n\t\t\t});\n\t\t}\n\t}\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/ruleAppliedToaster.js\n// module id = 131\n// module chunks = 0\n//# sourceURL=webpack:///./app/ruleAppliedToaster.js?")},132:function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _ractive = __webpack_require__(1);\n\nvar _ractive2 = _interopRequireDefault(_ractive);\n\nvar _nitroApi = __webpack_require__(2);\n\nvar _nitroApi2 = _interopRequireDefault(_nitroApi);\n\nvar _index = __webpack_require__(133);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _index3 = __webpack_require__(128);\n\nvar _index4 = _interopRequireDefault(_index3);\n\nvar _constants = __webpack_require__(127);\n\n__webpack_require__(134);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Default interval for polling networks and apps\n * @type {Number}\n */\nvar NET_POLLING_INTERVAL = 1000;\nvar APP_POLLING_INTERVAL = 1000;\n\nvar MODE_SWITCH_ID_PREFIX = 'firewallModeSwitch';\n\nvar IPM_BUY_ELM = 343;\nvar FEATURE_ID = 'firewall';\n\nexports.default = _ractive2.default.extend({\n\ttemplate: _index2.default,\n\tcss: _index4.default,\n\tcomponents: {},\n\tdata: function data() {\n\t\treturn {\n\t\t\tMODES: _constants.MODES,\n\t\t\tSTATUSES: _constants.STATUSES,\n\t\t\tMODE_SWITCH_ID_PREFIX: MODE_SWITCH_ID_PREFIX,\n\t\t\tstatus: {},\n\t\t\tfirewallSwitchDisabled: true,\n\t\t\tconnectedNets: [],\n\t\t\tapps: [],\n\t\t\tproduct: _nitroApi2.default.ProductModel.getProduct(),\n\t\t\tlicensed: _nitroApi2.default.ProductModel.isLicensed(FEATURE_ID)\n\t\t};\n\t},\n\tcomputed: {\n\t\tfirewallActive: {\n\t\t\tset: function set() {}, // causes an error without this\n\t\t\tget: function get() {\n\t\t\t\treturn this.get('status.status') === _constants.STATUSES.running;\n\t\t\t}\n\t\t}\n\t},\n\n\toninit: function oninit() {\n\t\tvar _this = this;\n\n\t\tthis.log = _nitroApi2.default.loggerManager.createLogger('firewall');\n\n\t\tthis.log.debug('oninit');\n\n\t\tthis.iconCache = {};\n\n\t\tthis.netExpansions = {};\n\n\t\tthis.offProductChanged = _nitroApi2.default.on('product.change.state.product', function (product) {\n\t\t\t_this.log.c.isDebug && _this.log.debug('product changed; product: ' + product);\n\n\t\t\t_this.set('product', product);\n\t\t});\n\n\t\tthis.offFeatureChanged = _nitroApi2.default.on('product.change.feature.' + FEATURE_ID, function (data) {\n\t\t\t_this.log.c.isDebug && _this.log.debug('feature changed; data: ' + JSON.stringify(data));\n\n\t\t\t// data contains only the updated properties\n\t\t\tif (data.licensed !== undefined) {\n\t\t\t\t_this.set('licensed', data.licensed);\n\t\t\t}\n\t\t});\n\n\t\tthis.observe('licensed', function (licensed, oldLicensed) {\n\t\t\t_this.log.c.isInfo && _this.log.info('licensed changed from \"' + oldLicensed + '\" to \"' + licensed + '\"');\n\n\t\t\tif (licensed) {\n\t\t\t\t_this.initialize();\n\t\t\t} else {\n\t\t\t\t_this.terminate();\n\t\t\t}\n\t\t});\n\n\t\tthis.on('Upsell.init', function () {\n\t\t\t_nitroApi2.default.track.event('Upsell', 'View');\n\t\t});\n\n\t\tthis.on('Upsell.buy', function () {\n\t\t\t// openIpmWindow automatically ads the p_src parameter (nitro-ui-core)\n\t\t\t_nitroApi2.default.openIpmWindow(IPM_BUY_ELM);\n\t\t\t//NAPI.MainWindow.open('elm://' + IPM_BUY_ELM)\n\t\t});\n\n\t\tthis.on('toggleFirewall', this.onToggleFirewall.bind(this));\n\t\tthis.on('toggleMode', this.onToggleMode.bind(this));\n\n\t\tthis.on('toggleNetworkDetails', function (e, i) {\n\t\t\t// net polling needs to be stopped during this action\n\t\t\t// to not overwrite what is being set here\n\t\t\t_this.stopNetPolling && _this.stopNetPolling();\n\n\t\t\tvar net = _this.get('connectedNets.' + i);\n\t\t\tvar newExpanded = !net.expanded;\n\n\t\t\t_this.netExpansions[_this.getNetId(net)] = newExpanded;\n\n\t\t\t_this.set('connectedNets.' + i + '.expanded', newExpanded);\n\n\t\t\t_this.startNetPolling();\n\t\t});\n\n\t\tthis.on('showNetConnections', function () {\n\t\t\t_nitroApi2.default.request('av.command', 'show_network_connections');\n\t\t});\n\n\t\tthis.on('showFirewallLogs', function () {\n\t\t\t_this.log.debug('opening firewall logs');\n\n\t\t\t_nitroApi2.default.request('av.command', 'show_fw_logs');\n\t\t});\n\n\t\tthis.on('showAppRules', function () {\n\t\t\t_this.log.debug('opening app rulez');\n\n\t\t\t_nitroApi2.default.request('av.command', 'show_fw_app_rules');\n\t\t});\n\n\t\tthis.on('openSettings', function () {\n\t\t\t_this.log.debug('opening settings');\n\n\t\t\t_nitroApi2.default.request('av.command', 'settings(dialog=IDR_HTM_DIALOG_SETTINGS_FW)');\n\t\t});\n\n\t\tthis.initialize();\n\t},\n\tonteardown: function onteardown() {\n\t\tthis.log.debug('onteardown');\n\n\t\tthis.terminate();\n\n\t\tthis.offProductChanged && this.offProductChanged();\n\t\tthis.offFeatureChanged && this.offFeatureChanged();\n\t},\n\tinitialize: function initialize() {\n\t\tif (!this.get('licensed')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.offStatusChanged = _nitroApi2.default.on('firewall.onStatusChanged.*', this.onStatusChanged.bind(this));\n\t\tthis.pollStatus();\n\n\t\tthis.startNetPolling();\n\t\tthis.startAppPolling();\n\t},\n\tterminate: function terminate() {\n\t\tthis.stopNetPolling && this.stopNetPolling();\n\t\tthis.stopAppPolling && this.stopAppPolling();\n\n\t\tthis.offStatusChanged && this.offStatusChanged();\n\t\tthis.offStatusChanged = null;\n\t},\n\tonToggleFirewall: function onToggleFirewall(e) {\n\t\tvar _this2 = this;\n\n\t\te.original.preventDefault();\n\n\t\tvar firewallActive = this.get('firewallActive');\n\t\tvar actionId = firewallActive ? 'app.firewall.Stop' : 'app.firewall.Start';\n\t\tvar action = function action(params) {\n\t\t\t_this2.set('firewallSwitchDisabled', true);\n\n\t\t\t_nitroApi2.default.request(actionId, params).then(function () {\n\t\t\t\t_this2.log.info('firewall successfully ' + (firewallActive ? 'stopped' : 'started'));\n\t\t\t}).catch(function (e) {\n\t\t\t\t_this2.log.error('error while executing ' + actionId + '; error: ' + e);\n\n\t\t\t\t_this2.set('firewallSwitchDisabled', false);\n\t\t\t});\n\t\t};\n\n\t\tif (firewallActive) {\n\t\t\tvar nls = _ractive2.default.localization.nls;\n\n\t\t\tthis.log.info('opening the stop option dialog');\n\n\t\t\t_ractive2.default.UI.stopOptions({\n\t\t\t\ttitle: nls('firewall.stopOptions.title'),\n\t\t\t\tdesc: nls('firewall.stopOptions.desc')\n\t\t\t}).then(function (optionParams) {\n\t\t\t\tvar params = {};\n\n\t\t\t\t_this2.log.info('stopping firewall; option: ' + JSON.stringify(optionParams));\n\n\t\t\t\tif (optionParams.time > 0) {\n\t\t\t\t\tparams.restartAfterInterval = optionParams.time;\n\t\t\t\t} else if (optionParams.time === 0) {\n\t\t\t\t\tparams.restartAfterReboot = true;\n\t\t\t\t}\n\n\t\t\t\taction(params);\n\t\t\t}).catch(function () {\n\t\t\t\t_this2.log.info('no stop option selected.. doing nothing');\n\t\t\t});\n\t\t} else if (this._isPassiveMode()) {\n\t\t\tthis.log.info('opening passive mode dialog');\n\n\t\t\tthis._showPassiveModeModal(action);\n\t\t} else {\n\t\t\tthis.log.info('starting firewall');\n\n\t\t\taction();\n\t\t}\n\t},\n\n\n\t/**\n * Displays modal dialog with possibility to turn passive mode off\n * @private\n */\n\t_showPassiveModeModal: function _showPassiveModeModal(action) {\n\t\tvar _this3 = this;\n\n\t\tvar message = _ractive2.default.localization.nls('global.passiveModeModal.desc1') + '<br><br>' + _ractive2.default.localization.nls('global.passiveModeModal.desc2') + '<br><br>' + _ractive2.default.localization.nls('global.passiveModeModal.desc3') + '<br>';\n\n\t\tvar options = {\n\t\t\ttitle: _ractive2.default.localization.nls('global.passiveModeModal.title'),\n\t\t\tok: _ractive2.default.localization.nls('global.yes'),\n\t\t\tcancel: _ractive2.default.localization.nls('global.passiveModeModal.stayInPassiveMode')\n\t\t};\n\n\t\treturn _ractive2.default.UI.confirm(message, options).then(function () {\n\t\t\t_nitroApi2.default.request('app.utils.EnablePassiveMode', {\n\t\t\t\tenable: false\n\t\t\t}).then(function () {\n\t\t\t\t_this3.log.info('starting firewall');\n\t\t\t\taction();\n\t\t\t});\n\t\t});\n\t},\n\n\n\t/**\n * Returns if product is in passive mode or passive mode locked\n * @private\n * @return {Boolean} if product is in passive mode\n */\n\t_isPassiveMode: function _isPassiveMode() {\n\t\tvar issues = _nitroApi2.default.ProductModel.getIssues();\n\t\treturn issues['passive_mode'] || issues['passive_mode_locked'];\n\t},\n\tonToggleMode: function onToggleMode(e) {\n\t\tvar _this4 = this;\n\n\t\te.original.preventDefault();\n\n\t\tvar checkbox = e.node;\n\t\tvar netPath = 'connectedNets.' + checkbox.id.replace(MODE_SWITCH_ID_PREFIX, '');\n\t\tvar net = this.get(netPath);\n\t\tvar newMode = this.get(netPath + '.mode') === _constants.MODES.private ? _constants.MODES.public : _constants.MODES.private;\n\t\tvar params = {\n\t\t\trouterAddress: net.routerAddress,\n\t\t\tadapterName: net.adapterName,\n\t\t\tmode: newMode\n\t\t};\n\t\tvar prerequest = function prerequest() {\n\t\t\t_this4.set(netPath + '.modeSwitchDisabled', true);\n\t\t\t_this4.stopNetPolling && _this4.stopNetPolling();\n\t\t};\n\t\tvar postrequest = function postrequest() {\n\t\t\t_this4.set(netPath + '.modeSwitchDisabled', false);\n\t\t\t_this4.startNetPolling();\n\t\t};\n\n\t\tprerequest();\n\n\t\tthis.log.info('setting network profile; params: ' + JSON.stringify(params));\n\n\t\t_nitroApi2.default.request('app.firewall.SetNetworkProfile', params).then(function () {\n\t\t\t_this4.log.info('network profile successfully set; params: ' + JSON.stringify(params));\n\n\t\t\tpostrequest();\n\t\t}).catch(function (e) {\n\t\t\t_this4.log.error('error while executing app.firewall.SetNetworkProfile; error: ' + e);\n\n\t\t\tpostrequest();\n\t\t});\n\t},\n\tonStatusChanged: function onStatusChanged(statusData) {\n\t\tthis.log.info('status changed');\n\t\tthis.log.debug('status data: ' + JSON.stringify(statusData));\n\n\t\tthis.set('status', statusData);\n\t\tthis.set('firewallSwitchDisabled', false);\n\t},\n\tpollStatus: function pollStatus() {\n\t\tvar _this5 = this;\n\n\t\tthis.log.info('polling status data');\n\n\t\t_nitroApi2.default.request('app.firewall.GetStatus').then(function (statusData) {\n\t\t\t_this5.log.info('status data polled');\n\n\t\t\t_this5.onStatusChanged(statusData);\n\t\t}).catch(function (e) {\n\t\t\t_this5.log.error('error while executing app.firewall.GetStatus; error: ' + e);\n\t\t});\n\t},\n\tpollNets: function pollNets() {\n\t\tvar _this6 = this;\n\n\t\tvar log = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n\t\tlog && this.log.info('polling nets');\n\n\t\t_nitroApi2.default.request('app.firewall.GetNetworkProfiles').then(function (nets) {\n\t\t\tvar connectedNets = [];\n\n\t\t\tlog && _this6.log.info('nets polled');\n\t\t\tlog && _this6.log.debug('nets: ' + JSON.stringify(nets));\n\n\t\t\tif (nets && nets.length) {\n\t\t\t\tconnectedNets = nets.filter(function (net) {\n\t\t\t\t\tif (net.isConnected) {\n\t\t\t\t\t\tnet.modeSwitchDisabled = false;\n\t\t\t\t\t\tnet.expanded = _this6.netExpansions[_this6.getNetId(net)];\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t_this6.set('connectedNets', connectedNets);\n\t\t}).catch(function (e) {\n\t\t\t_this6.log.error('error while executing app.firewall.GetNetworkProfiles; error: ' + e);\n\t\t});\n\t},\n\tpollApps: function pollApps() {\n\t\tvar _this7 = this;\n\n\t\tvar log = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n\t\tlog && this.log.info('polling apps');\n\n\t\t_nitroApi2.default.request('app.firewall.GetLastFwApps').then(function (apps) {\n\t\t\tlog && _this7.log.info('apps polled');\n\t\t\tlog && _this7.log.debug('apps: ' + JSON.stringify(apps));\n\n\t\t\tvar APP_MAX_COUNT = 6;\n\t\t\tvar allApps = apps.blocked.slice(0, 3).map(function (app) {\n\t\t\t\tapp.blocked = true;\n\t\t\t\treturn app;\n\t\t\t});\n\n\t\t\tallApps = allApps.concat(apps.allowed.slice(0, APP_MAX_COUNT - allApps.length));\n\n\t\t\t_this7.set('apps', allApps);\n\n\t\t\tallApps.forEach(function (app, i) {\n\t\t\t\tif (_this7.iconCache[app.path]) {\n\t\t\t\t\t_this7.set('apps.' + i + '.icon', _this7.iconCache[app.path]);\n\t\t\t\t} else {\n\t\t\t\t\t_this7.loadAppIcon(app.path).then(function (iconData) {\n\t\t\t\t\t\t_this7.set('apps.' + i + '.icon', iconData);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}).catch(function (e) {\n\t\t\t_this7.log.error('error while executing app.firewall.GetLastFwApps; error: ' + e);\n\t\t});\n\t},\n\n\n\t/**\n  * Starts asking for net list every second to keep the UI up-to-date.\n  * @return {Function} Function which stops the polling\n  */\n\tstartNetPolling: function startNetPolling() {\n\t\tvar _this8 = this;\n\n\t\tthis.log.info('starting net polling; interval: ' + NET_POLLING_INTERVAL + ' ms');\n\n\t\tthis.stopNetPolling && this.stopNetPolling();\n\n\t\tvar intervalId = setInterval(this.pollNets.bind(this, false), NET_POLLING_INTERVAL);\n\n\t\tthis.stopNetPolling = function () {\n\t\t\t_this8.log.info('stopping net polling');\n\n\t\t\tclearInterval(intervalId);\n\t\t\t_this8.stopNetPolling = null;\n\t\t};\n\n\t\t// not having to wait for the first interval\n\t\tthis.pollNets();\n\t},\n\n\n\t/**\n  * Starts asking for app list every second to keep the UI up-to-date.\n  * @return {Function} Function which stops the polling\n  */\n\tstartAppPolling: function startAppPolling() {\n\t\tvar _this9 = this;\n\n\t\tthis.log.info('starting app polling; interval: ' + APP_POLLING_INTERVAL + ' ms');\n\n\t\tthis.stopAppPolling && this.stopAppPolling();\n\n\t\tvar intervalId = setInterval(this.pollApps.bind(this, false), APP_POLLING_INTERVAL);\n\n\t\tthis.stopAppPolling = function () {\n\t\t\t_this9.log.info('stopping app polling');\n\n\t\t\tclearInterval(intervalId);\n\t\t\t_this9.stopAppPolling = null;\n\t\t};\n\n\t\t// not having to wait for the first interval\n\t\tthis.pollApps();\n\t},\n\n\n\t/**\n  * Get and cache icon base-64 data\n  *\n  * @param  {String} path of the exe file which the icon is loaded from\n  * @return {Promise}\n  */\n\tloadAppIcon: function loadAppIcon(path) {\n\t\tvar _this10 = this;\n\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\t_nitroApi2.default.request('app.utils.GetShellIcon', {\n\t\t\t\tpath: path,\n\t\t\t\tsize: 'large'\n\t\t\t}).then(function (icon) {\n\t\t\t\t_this10.iconCache[path] = icon.data;\n\t\t\t\tresolve(icon.data);\n\t\t\t}).catch(function (e) {\n\t\t\t\t_this10.log.error('error while executing app.utils.GetShellIcon. Path ' + path + '; error: ' + e);\n\n\t\t\t\treject();\n\t\t\t});\n\t\t});\n\t},\n\tgetNetId: function getNetId(net) {\n\t\treturn net.routerAddress + '_' + net.adapterName;\n\t}\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/index.js\n// module id = 132\n// module chunks = 0\n//# sourceURL=webpack:///./app/index.js?");
},133:function(module,exports){eval('module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":"color-security -bg nui_page"},"f":[{"t":7,"e":"Header","a":{"section":"security","moduleId":"firewall","innerYield":"true","scrollUnder":"brand"},"f":[{"t":4,"f":[{"t":7,"e":"Info","a":{"title":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall\\")"}}]},"f":[{"t":7,"e":"Carousel","f":[{"t":7,"e":"div","a":{"class":"nui_carousel__flex"},"f":[{"t":7,"e":"h2","a":{"class":"h3 -margins"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.desc.1.title\\")"}}]}," ",{"t":7,"e":"p","a":{"class":"p"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.desc.1.text\\")"}}]}]}," ",{"t":7,"e":"div","a":{"class":"nui_carousel__flex"},"f":[{"t":7,"e":"h2","a":{"class":"h3 -margins"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.desc.2.title\\")"}}]}," ",{"t":7,"e":"p","a":{"class":"p"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.desc.2.text\\")"}}]}]}," ",{"t":7,"e":"div","a":{"class":"nui_carousel__flex"},"f":[{"t":7,"e":"h2","a":{"class":"h3 -margins"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.desc.3.title\\")"}}]}," ",{"t":7,"e":"p","a":{"class":"p"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.desc.3.text\\")"}}]}]}," ",{"t":7,"e":"div","a":{"class":"nui_carousel__flex"},"f":[{"t":7,"e":"h2","a":{"class":"h3 -margins"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.desc.4.title\\")"}}]}," ",{"t":7,"e":"p","a":{"class":"p"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.desc.4.text\\")"}}]}]}]}]}],"n":50,"r":"licensed"},{"t":4,"n":51,"f":[{"t":7,"e":"Icon","a":{"name":"lock-full","cssCls":"color-attention -text g-margin-left--10"}}],"r":"licensed"}," ",{"t":4,"f":[{"t":7,"e":"Switch","a":{"attr":"{id:\'firewallSwitch\'}","txt":["{on:\'",{"t":3,"x":{"r":["nls"],"s":"_0(\\"global.switcher.on\\")"}},"\', off:\'",{"t":3,"x":{"r":["nls"],"s":"_0(\\"global.switcher.off\\")"}},"\'}"],"checked":[{"t":2,"r":"firewallActive"}],"disabled":[{"t":2,"r":"firewallSwitchDisabled"}],"isCheckbox":"false","cssCls":[{"t":4,"f":["-waiting"],"n":50,"r":"firewallSwitchDisabled"}]},"v":{"domClick":"toggleFirewall"}}],"n":50,"r":"licensed"}]}," ",{"t":4,"f":[" ",{"t":7,"e":"div","a":{"class":"nui_page__scroll frw_main"},"f":[{"t":7,"e":"h3","a":{"class":"h3 -margins frw_half"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.currentNetwork\\")"}}]}," ",{"t":4,"f":[{"t":7,"e":"h3","a":{"class":"h3 -margins frw_half"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.mode\\")"}}]}," ",{"t":4,"f":[{"t":7,"e":"div","a":{"class":"frw_network color-white -bg g-clearfix"},"f":[{"t":7,"e":"div","a":{"class":"frw_connected__status color-ok -bg"}}," ",{"t":7,"e":"div","a":{"class":"frw_connected frw_half"},"f":[{"t":7,"e":"Icon","a":{"name":["network-",{"t":2,"x":{"r":["isLan"],"s":"_0?\\"lan\\":\\"wifi\\""}}],"cssCls":"frw_network__icon color-ok -text"}}," ",{"t":7,"e":"div","a":{"class":"frw_network__details"},"f":[{"t":7,"e":"h4","a":{"class":"h4"},"f":[{"t":2,"r":"networkName"}]}," ",{"t":7,"e":"p","a":{"class":"p -small color-ok -text"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.network.connected\\")"}}]}," ",{"t":4,"f":[{"t":7,"e":"p","a":{"class":"p -small -secondary g-margin-top--10"},"t0":"slide","f":[{"t":2,"r":"adapterName"},{"t":7,"e":"br"}," ",{"t":7,"e":"span","a":{"class":"frw_label"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.macAddress\\")"}},":"]},{"t":2,"r":"routerAddress"}]}],"r":"expanded"}]}]}," ",{"t":7,"e":"div","a":{"class":"frw_mode frw_half"},"f":[{"t":7,"e":"Switch","a":{"attr":["{id: \'",{"t":2,"r":"MODE_SWITCH_ID_PREFIX"},{"t":2,"r":"i"},"\'}"],"txt":["{left:\'",{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.mode.private\\")"}},"\',right:\'",{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.mode.public\\")"}},"\'}"],"checked":[{"t":2,"r":"mode"}],"isCheckbox":"false","values":["{left:\'",{"t":2,"r":"MODES.private"},"\',right:\'",{"t":2,"r":"MODES.public"},"\'}"],"disabled":[{"t":2,"r":"modeSwitchDisabled"}],"cssCls":[{"t":4,"f":["-waiting"],"n":50,"r":"modeSwitchDisabled"}]},"v":{"domClick":"toggleMode"}}," ",{"t":4,"f":[{"t":7,"e":"p","a":{"class":"p -small g-margin-top--10"},"t0":"slide","f":[{"t":4,"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.mode.home.desc\\")"}}],"n":50,"x":{"r":["mode","MODES.private"],"s":"_0===_1"}},{"t":4,"n":51,"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.mode.public.desc\\")"}}],"x":{"r":["mode","MODES.private"],"s":"_0===_1"}}]}],"r":"expanded"}]}," "]}],"n":52,"i":"i","r":"connectedNets"}],"n":50,"x":{"r":["connectedNets","connectedNets.length"],"s":"_0&&_1"}},{"t":4,"n":51,"f":[{"t":7,"e":"div","a":{"class":"frw_empty color-white -bg g-margin-bottom--5","data-nitro_test":"frw_noConnectedNets"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.noConnectedNetworkFound\\")"}}]}],"x":{"r":["connectedNets","connectedNets.length"],"s":"_0&&_1"}}," ",{"t":7,"e":"div","a":{"class":"frw_links text -small"},"f":[{"t":7,"e":"button","v":{"click":"showNetConnections"},"a":{"class":"a","data-nitro_test":"frw_connections"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.networkConnections\\")"}}]},"|",{"t":7,"e":"button","v":{"click":"showFirewallLogs"},"a":{"class":"a","data-nitro_test":"frw_logs"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.firewallLogs\\")"}}]},"|",{"t":7,"e":"button","v":{"click":"openSettings"},"a":{"class":"a","data-nitro_test":"frw_settings"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.settings\\")"}}]}]}," ",{"t":7,"e":"h3","a":{"class":"h3 -margins g-margin-top--20"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.recentAppsManagedByFirewall\\")"}}]}," ",{"t":7,"e":"div","a":{"class":"frw_apps color-white -bg g-clearfix"},"f":[{"t":4,"f":[{"t":4,"f":[{"t":7,"e":"button","v":{"click":"showAppRules"},"a":{"class":"frw_app hover"},"f":[{"t":7,"e":"ImgIcon","a":{"src":["data:image/png;base64,",{"t":2,"r":"icon"}],"cssCls":"frw_app__icon"}}," ",{"t":4,"f":[{"t":7,"e":"Icon","a":{"name":"blocked","cssCls":"color-danger -text frw_app__blocked"}}],"n":50,"r":"blocked"}," ",{"t":7,"e":"p","a":{"class":"p -small"},"f":[{"t":2,"r":"name"}]}," ",{"t":7,"e":"p","a":{"class":"p -small -secondary"},"f":[{"t":4,"f":[{"t":7,"e":"span","a":{"class":"color-danger -text"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.app.blocked\\")"}}]}],"n":50,"r":"blocked"},{"t":4,"n":51,"f":[{"t":7,"e":"span","a":{"class":"color-ok -text"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.app.allowed\\")"}}]}],"r":"blocked"}]}]}],"n":52,"r":"apps"}],"n":50,"x":{"r":["apps","apps.length"],"s":"_0&&_1"}},{"t":4,"n":51,"f":[{"t":7,"e":"div","a":{"class":"frw_empty color-white -bg"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.noManagedAppFound\\")"}}]}],"x":{"r":["apps","apps.length"],"s":"_0&&_1"}}]}," ",{"t":7,"e":"div","a":{"class":"frw_links text -small"},"f":[{"t":7,"e":"button","v":{"click":"showAppRules"},"a":{"class":"a","data-nitro_test":"frw_rules"},"f":[{"t":3,"x":{"r":["nls"],"s":"_0(\\"firewall.applicationRules\\")"}}]}]}]}],"n":50,"r":"licensed"},{"t":4,"n":51,"f":[{"t":7,"e":"Upsell","a":{"name":"firewall"}}],"r":"licensed"}]}]};\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/index.html\n// module id = 133\n// module chunks = 0\n//# sourceURL=webpack:///./app/index.html?')},134:function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Installer = __webpack_require__(135);\n\nvar _Installer2 = _interopRequireDefault(_Installer);\n\nvar _utils = __webpack_require__(139);\n\nvar _consts = __webpack_require__(136);\n\nvar _nitroUiLibEventEmitter = __webpack_require__(137);\n\nvar _nitroUiLibEventEmitter2 = _interopRequireDefault(_nitroUiLibEventEmitter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Injects new ProductModel instance upon NAPI\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * if NAPI exists but ProductModel is not present.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * If NAPI does not exists or it already has ProductModel\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * it does nothing.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * It does no export, just the injection.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WARNING: don't import NAPI or something from it,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * it would break the common instance of NAPI in the modules\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * where this lib would be used.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * ProductModel is supposed to work and be created only in environment with window.NAPI.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\nvar features = {};\nvar standalones = {};\nvar state = {};\nvar userConfig = {};\nvar product = {};\nvar subscriptionService = null;\nvar subscriptionOffChange = null;\nvar log = null;\n\nfunction updateStatus(data) {\n\tlog && log.info('updating status');\n\n\tvar updated = {};\n\tvar updatedUserConfig = {};\n\n\tfor (var key in data.userConfig) {\n\t\tif (userConfig[key] !== data.userConfig[key]) {\n\t\t\tuserConfig[key] = updatedUserConfig[key] = data.userConfig[key];\n\t\t}\n\t}\n\n\tfor (var _key in data) {\n\t\tif (_key !== 'features' && _key !== 'standalones' && _key !== 'userConfig' && product[_key] !== data[_key]) {\n\t\t\tproduct[_key] = updated[_key] = data[_key];\n\t\t}\n\t}\n\n\tif (Object.keys(updated).length) {\n\t\tlog && log.info('status changed.. emitting events');\n\t\tlog && log.c.isDebug && log.debug('status: ' + JSON.stringify(updated));\n\n\t\t// Emit change events....\n\t\tNAPI.emitInternal('product.change', updated);\n\n\t\tNAPI.emitInternal('product.change.userConfig', updated.userConfig);\n\n\t\tfor (var _key2 in updated) {\n\t\t\tNAPI.emitInternal('product.change.' + _key2, updated[_key2]);\n\t\t\tif (_key2 === 'userConfig') {\n\t\t\t\tfor (var k in updated.userConfig) {\n\t\t\t\t\tNAPI.emitInternal('product.change.userConfig.' + k, updated.userConfig[_key2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog && log.info('no status change');\n\t}\n\n\treturn updated;\n}\n\nfunction updateFeatures(data) {\n\tlog && log.info('updating features');\n\n\tvar updated = {};\n\n\t// when subscriptionService gets ready, the update will be triggered again\n\tif (subscriptionService) {\n\t\t// injecting info into specific features about their premium status\n\t\tPromise.all(_consts.PREMIUM_FEATURES.map(function (p) {\n\t\t\treturn subscriptionService.isLicensed(p);\n\t\t})).then(function (premiumResults) {\n\n\t\t\t_consts.PREMIUM_FEATURES.forEach(function (feature, i) {\n\t\t\t\tvar key = _consts.FEATURE_IDS[feature];\n\t\t\t\tif (data[key]) {\n\t\t\t\t\tdata[key].premium = premiumResults[i];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t_goOn();\n\t\t}).catch(_goOn);\n\t} else {\n\t\t_goOn();\n\t}\n\n\tfunction _goOn() {\n\t\tfor (var key in data) {\n\t\t\tvar label = _consts.FEATURES_MAP[key];\n\n\t\t\tif (features[key]) {\n\t\t\t\tfor (var prop in data[key]) {\n\t\t\t\t\tif (features[key][prop] !== data[key][prop]) {\n\t\t\t\t\t\tif (!updated[key]) {\n\t\t\t\t\t\t\tupdated[key] = {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfeatures[key][prop] = updated[key][prop] = data[key][prop];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (label) {\n\t\t\t\t\t\tfeatures[label] = features[label] || features[key];\n\n\t\t\t\t\t\tif (updated[key]) {\n\t\t\t\t\t\t\tupdated[label] = updated[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfeatures[key] = updated[key] = data[key];\n\t\t\t\tfeatures[label] = updated[label] = data[key];\n\t\t\t}\n\t\t}\n\n\t\tif (Object.keys(updated).length) {\n\t\t\tlog && log.info('features changed.. emitting events');\n\t\t\tlog && log.c.isDebug && log.debug('features: ' + JSON.stringify(updated));\n\n\t\t\t// Emit change events....\n\t\t\tNAPI.emitInternal('product.change', {\n\t\t\t\tfeatures: updated\n\t\t\t});\n\t\t\tNAPI.emitInternal('product.change.feature', updated);\n\n\t\t\tfor (var _key3 in updated) {\n\t\t\t\tNAPI.emitInternal('product.change.feature.' + _key3, updated[_key3]);\n\t\t\t}\n\t\t} else {\n\t\t\tlog && log.info('no feature change');\n\t\t}\n\t}\n}\n\nfunction updateStandalones(newStandalones) {\n\tlog && log.info('updating standalones');\n\n\tvar updated = {};\n\n\t// find out what was updated\n\t// Warning: at this time it doesn't take in account deleted standalones and properties\n\tfor (var id in newStandalones) {\n\t\tvar key = _consts.STANDALONES_MAP[id];\n\n\t\tif (standalones[key]) {\n\t\t\tfor (var prop in newStandalones[id]) {\n\t\t\t\tif (standalones[key][prop] !== newStandalones[id][prop]) {\n\t\t\t\t\tupdated[key] = updated[key] || {};\n\n\t\t\t\t\tstandalones[key][prop] = updated[key][prop] = newStandalones[id][prop];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstandalones[key] = newStandalones[id];\n\t\t}\n\t}\n\n\tif (Object.keys(updated).length) {\n\t\tlog && log.info('standalones changed.. emitting events');\n\t\tlog && log.c.isDebug && log.debug('standalones: ' + JSON.stringify(updated));\n\n\t\t// Emit change events....\n\t\tNAPI.emitInternal('product.change', { standalones: updated });\n\n\t\tNAPI.emitInternal('product.change.standalone', updated);\n\n\t\tfor (var _prop in updated) {\n\t\t\tNAPI.emitInternal('product.change.standalone.' + _prop, updated[_prop]);\n\t\t}\n\t} else {\n\t\tlog && log.info('no standalone change');\n\t}\n}\n\nfunction updateState(data) {\n\tlog && log.info('updating state');\n\n\tvar updated = {};\n\n\tfor (var key in data) {\n\t\tif (!(0, _utils.isEqual)(state[key], data[key])) {\n\t\t\tstate[key] = updated[key] = data[key];\n\t\t}\n\t}\n\n\tif (Object.keys(updated).length) {\n\t\tlog && log.info('state changed.. emitting events');\n\t\tlog && log.c.isDebug && log.debug('state: ' + JSON.stringify(updated));\n\n\t\t// Emit change events....\n\t\tNAPI.emitInternal('product.change', {\n\t\t\tstate: updated\n\t\t});\n\n\t\tNAPI.emitInternal('product.change.state', updated);\n\n\t\tfor (var _key4 in updated) {\n\t\t\tNAPI.emitInternal('product.change.state.' + _key4, updated[_key4]);\n\t\t}\n\t} else {\n\t\tlog && log.info('no state change');\n\t}\n\n\treturn updated;\n}\n\nfunction updateStatusAndFeaturesAndStandalones() {\n\tlog && log.info('updating status, features and standalones');\n\n\treturn NAPI.request('app.product.GetStatus').then(function (data) {\n\t\tupdateStatus(data);\n\t\tupdateFeatures(data.features);\n\t\tupdateStandalones(data.standalones);\n\t});\n}\n\nvar ProductModel = function (_EventEmitter) {\n\t_inherits(ProductModel, _EventEmitter);\n\n\tfunction ProductModel() {\n\t\t_classCallCheck(this, ProductModel);\n\n\t\tvar _this = _possibleConstructorReturn(this, (ProductModel.__proto__ || Object.getPrototypeOf(ProductModel)).call(this));\n\n\t\tif (NAPI.loggerManager) {\n\t\t\tlog = NAPI.loggerManager.createLogger('napi.productModel');\n\t\t} else {\n\t\t\tconsole.log('NAPI: loggerManager not available');\n\t\t}\n\n\t\tlog && log.info('created');\n\n\t\tNAPI.on('moduleManager.definition.done', function () {\n\t\t\tlog && log.info('module definition done.. getting subscriptionService');\n\n\t\t\tNAPI.module('Subscriptions', 'serviceProxy').then(function (service) {\n\t\t\t\tlog && log.info('subscriptionService received');\n\n\t\t\t\tsubscriptionService = service;\n\n\t\t\t\tsubscriptionOffChange && subscriptionOffChange();\n\t\t\t\tsubscriptionOffChange = service.on('licensesChanged', updateStatusAndFeaturesAndStandalones);\n\n\t\t\t\tupdateStatusAndFeaturesAndStandalones();\n\t\t\t}).catch(function () {\n\t\t\t\tlog && log.warn('getting subscriptionService failed');\n\t\t\t});\n\t\t});\n\n\t\tNAPI.on('product.onStatusChanged.*', function (data) {\n\t\t\tlog && log.info('product status changed');\n\t\t\tlog && log.c.isDebug && log.debug('data: ' + JSON.stringify(data));\n\n\t\t\tupdateStatus(data);\n\t\t\tupdateFeatures(data.features);\n\t\t\tupdateStandalones(data.standalones);\n\t\t});\n\n\t\tNAPI.on('avService.onStatusChanged.*', function (data) {\n\t\t\tlog && log.info('service state changed');\n\t\t\tlog && log.c.isDebug && log.debug('data: ' + JSON.stringify(data));\n\n\t\t\tupdateState(data);\n\t\t});\n\n\t\treturn _this;\n\t}\n\n\t_createClass(ProductModel, [{\n\t\tkey: 'update',\n\t\tvalue: function update() {\n\t\t\tlog && log.info('updating all');\n\n\t\t\treturn Promise.all([\n\t\t\t// AV program state\n\t\t\tNAPI.request('app.avService.GetStatus').then(updateState),\n\t\t\t// AV default settings\n\t\t\tupdateStatusAndFeaturesAndStandalones()]);\n\t\t}\n\t}, {\n\t\tkey: 'resolveAll',\n\t\tvalue: function resolveAll() {\n\t\t\treturn NAPI.request('app.avService.ResolveAll');\n\t\t}\n\t}, {\n\t\tkey: 'getState',\n\t\tvalue: function getState() {\n\t\t\treturn JSON.parse(JSON.stringify(state));\n\t\t}\n\t}, {\n\t\tkey: 'getNewMesagesCount',\n\t\tvalue: function getNewMesagesCount() {\n\t\t\treturn state.ncUnreadItemsCount;\n\t\t}\n\t}, {\n\t\tkey: 'getNotifications',\n\t\tvalue: function getNotifications() {\n\t\t\treturn state.notifications;\n\t\t}\n\t}, {\n\t\tkey: 'getProblems',\n\t\tvalue: function getProblems() {\n\t\t\treturn state.problems;\n\t\t}\n\t}, {\n\t\tkey: 'getStatus',\n\t\tvalue: function getStatus() {\n\t\t\treturn state.mainStatus;\n\t\t}\n\t}, {\n\t\tkey: 'getIssues',\n\t\tvalue: function getIssues() {\n\t\t\treturn state.issues || [];\n\t\t}\n\t}, {\n\t\tkey: 'getProduct',\n\t\tvalue: function getProduct() {\n\t\t\treturn state.product;\n\t\t}\n\t}, {\n\t\tkey: 'getProductInfo',\n\t\tvalue: function getProductInfo() {\n\t\t\treturn product;\n\t\t}\n\t}, {\n\t\tkey: 'getGroups',\n\t\tvalue: function getGroups() {\n\t\t\treturn state.groups;\n\t\t}\n\t}, {\n\t\tkey: 'getUserConfig',\n\t\tvalue: function getUserConfig() {\n\t\t\treturn userConfig;\n\t\t}\n\t}, {\n\t\tkey: 'getLicense',\n\t\tvalue: function getLicense() {\n\t\t\treturn state.licType;\n\t\t}\n\t}, {\n\t\tkey: 'getExpiration',\n\t\tvalue: function getExpiration() {\n\t\t\treturn state.licExpDays;\n\t\t}\n\n\t\t// deprecated, use getFeature\n\n\t}, {\n\t\tkey: 'get',\n\t\tvalue: function get(feature) {\n\t\t\treturn this.getFeature(feature);\n\t\t}\n\t}, {\n\t\tkey: 'getFeature',\n\t\tvalue: function getFeature(feature) {\n\t\t\treturn features[feature];\n\t\t}\n\t}, {\n\t\tkey: 'isLicensed',\n\t\tvalue: function isLicensed(feature) {\n\t\t\treturn features[feature] ? features[feature].licensed : null;\n\t\t}\n\t}, {\n\t\tkey: 'isInstalled',\n\t\tvalue: function isInstalled(feature) {\n\t\t\treturn features[feature] ? features[feature].installed : null;\n\t\t}\n\t}, {\n\t\tkey: 'isEnabled',\n\t\tvalue: function isEnabled(feature) {\n\t\t\tif (!features[feature] || features[feature].enabled == undefined) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn features[feature].enabled;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Returns null in these cases\n   * - the feature does not exists,\n   * - cannot be premium,\n   * - failed to get the information.\n  \t * Returns boolean in other cases.\n   */\n\n\t}, {\n\t\tkey: 'isPremium',\n\t\tvalue: function isPremium(feature) {\n\t\t\tif (!features[feature] || features[feature].premium == undefined) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn features[feature].premium;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'getStandalone',\n\t\tvalue: function getStandalone(id) {\n\t\t\treturn standalones[id];\n\t\t}\n\t}, {\n\t\tkey: 'isStandaloneInstalled',\n\t\tvalue: function isStandaloneInstalled(id) {\n\t\t\treturn !!(standalones[id] && standalones[id].installed);\n\t\t}\n\t}, {\n\t\tkey: 'canUse',\n\t\tvalue: function canUse(feature) {\n\t\t\treturn this.isInstalled(feature) && this.isEnabled(feature) && this.isLicensed(feature);\n\t\t}\n\t}, {\n\t\tkey: 'install',\n\t\tvalue: function install(feature) {\n\t\t\t// create installer\n\t\t\tvar inst = this.getInstaller(feature);\n\t\t\tinst.install();\n\t\t\treturn inst;\n\t\t}\n\t\t/*\n  uninstall (feature) {\n  \t// TODO - no API yet\n  \tconst inst = this.getInstaller(feature);\n  \tinst.uninstall();\n  \treturn inst;\n  }\n  */\n\n\t}, {\n\t\tkey: 'getInstaller',\n\t\tvalue: function getInstaller(feature) {\n\t\t\tvar _this2 = this;\n\n\t\t\tvar inst = new _Installer2.default(feature);\n\t\t\tinst.once('done', function () {\n\t\t\t\t_this2.update();\n\t\t\t});\n\t\t\treturn inst;\n\t\t}\n\t}]);\n\n\treturn ProductModel;\n}(_nitroUiLibEventEmitter2.default);\n\n// don't import NAPI cuz it would create another instance than window.NAPI\n\n\nif (NAPI && !NAPI.ProductModel) {\n\tNAPI.ProductModel = new ProductModel();\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nitro-ui-lib-productModel/libs/index.js\n// module id = 134\n// module chunks = 0\n//# sourceURL=webpack:///./~/nitro-ui-lib-productModel/libs/index.js?")},135:function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _consts = __webpack_require__(136);\n\nvar _nitroUiLibEventEmitter = __webpack_require__(137);\n\nvar _nitroUiLibEventEmitter2 = _interopRequireDefault(_nitroUiLibEventEmitter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** WARNING: don't import NAPI or something from it,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * it would break the common instance of NAPI in the modules\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * where this lib would be used.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * ProductModel is supposed to work and be created only in enviroment with window.NAPI.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n/**\n * Installs, uninstalls and informs about instalation progress of components.\n */\nvar Installer = function (_EventEmitter) {\n\t_inherits(Installer, _EventEmitter);\n\n\tfunction Installer(component) {\n\t\t_classCallCheck(this, Installer);\n\n\t\tvar _this = _possibleConstructorReturn(this, (Installer.__proto__ || Object.getPrototypeOf(Installer)).call(this));\n\n\t\t_this.component = _consts.FEATURE_IDS[component] || component;\n\n\t\t// find out if there is some task already running\n\t\t// if so and it's for the required component, set it up\n\t\t_this.statusPromise = NAPI.request('app.setup.GetStatus').then(_this._updateStatus.bind(_this));\n\t\treturn _this;\n\t}\n\n\t/**\n  * Caches status data\n  * and starts to observe changes if un/installing\n  * or stops observing if nothing is going on.\n  */\n\n\n\t_createClass(Installer, [{\n\t\tkey: '_updateStatus',\n\t\tvalue: function _updateStatus(data) {\n\t\t\t// if status is 'ready' there is no componentId in the data\n\t\t\tif (data.status === 'running' && data.componentId !== this.component) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (data.status === 'running' && (data.task === 'installing' || data.task === 'uninstalling')) {\n\n\t\t\t\tthis.sessionId = data.sessionId;\n\t\t\t\tthis.status = data.status;\n\t\t\t\tthis.progress = data.progress;\n\t\t\t\tthis.task = data.task;\n\n\t\t\t\tthis.emit('progress', data.progress);\n\n\t\t\t\tthis._startObservingStatus();\n\t\t\t} else {\n\t\t\t\t// if it was running and now it's ready means it's done\n\t\t\t\tif (data.status === 'ready' && this.status === 'running' && (this.task === 'installing' || this.task === 'uninstalling')) {\n\t\t\t\t\tthis.emit('done', this.task === 'installing' ? 'installed' : 'uninstalled');\n\t\t\t\t}\n\n\t\t\t\tthis.sessionId = null;\n\t\t\t\tthis.status = null;\n\t\t\t\tthis.progress = null;\n\t\t\t\tthis.task = null;\n\n\t\t\t\tthis._stopObservingStatus();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_startObservingStatus',\n\t\tvalue: function _startObservingStatus() {\n\t\t\tvar _this2 = this;\n\n\t\t\tif (this._offStatusChange) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._offStatusChange = NAPI.on('setup.onStatusChanged.ASW_NOTIF_SETUP_PROGRESS', function (data) {\n\t\t\t\tif (_this2.sessionId && data.sessionId === _this2.sessionId) {\n\t\t\t\t\t_this2._updateStatus(data);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: '_stopObservingStatus',\n\t\tvalue: function _stopObservingStatus() {\n\t\t\tthis._offStatusChange && this._offStatusChange();\n\t\t}\n\t}, {\n\t\tkey: 'getStatus',\n\t\tvalue: function getStatus() {\n\t\t\tvar _this3 = this;\n\n\t\t\treturn this.statusPromise.then(function () {\n\t\t\t\treturn {\n\t\t\t\t\tsessionId: _this3.sessionId,\n\t\t\t\t\tstatus: _this3.status,\n\t\t\t\t\tprogress: _this3.progress,\n\t\t\t\t\ttask: _this3.task\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: 'install',\n\t\tvalue: function install() {\n\t\t\tvar _this4 = this;\n\n\t\t\treturn NAPI.request('app.setup.InstallComponent', {\n\t\t\t\tcomponent: this.component\n\t\t\t}).then(function (response) {\n\t\t\t\t// Don't wait for the event to set this cuz it may never come.\n\t\t\t\t// The installation may be so quick that we get event with status \"ready\" right away.\n\t\t\t\t_this4.status = 'running';\n\t\t\t\t_this4.progress = 0;\n\t\t\t\t_this4.task = 'installing';\n\n\t\t\t\t_this4.sessionId = response.sessionId;\n\n\t\t\t\t_this4._startObservingStatus();\n\t\t\t\treturn _this4;\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: 'uninstall',\n\t\tvalue: function uninstall() {\n\t\t\t// TODO - missing API\n\t\t}\n\t}, {\n\t\tkey: 'isInstalled',\n\t\tvalue: function isInstalled() {\n\t\t\treturn NAPI.request('app.setup.IsComponentInstalled', {\n\t\t\t\tcomponent: this.component\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * Should be called when the installer is no longer Needed\n   * to get rid of the observer.\n   */\n\n\t}, {\n\t\tkey: 'close',\n\t\tvalue: function close() {\n\t\t\tthis._stopObservingStatus();\n\t\t}\n\t}]);\n\n\treturn Installer;\n}(_nitroUiLibEventEmitter2.default);\n\nexports.default = Installer;\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nitro-ui-lib-productModel/libs/Installer.js\n// module id = 135\n// module chunks = 0\n//# sourceURL=webpack:///./~/nitro-ui-lib-productModel/libs/Installer.js?");
},136:function(module,exports){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nvar FEATURES_MAP = {\n\t'ais_shl_bhv': 'BehaviorShield',\n\t'ais_shl_fil': 'FileShield',\n\t'ais_shl_mai': 'MailShield',\n\t'ais_shl_web': 'WebShield',\n\t'ais_shl_spm': 'antispam',\n\t'ais_cmp_ara': 'RemoteAssistance',\n\t'ais_cmp_bpc': 'bpc',\n\t'ais_cmp_fw': 'firewall',\n\t'ais_cmp_gadget': 'gadget',\n\t'ais_cmp_grimefighter': 'cleanup',\n\t'ais_cmp_cleanup': 'cleanupPp',\n\t'ais_cmp_rescuedisk': 'rescuedisk',\n\t'ais_cmp_secureline': 'secureline',\n\t'ais_cmp_sfzone': 'safezone',\n\t'ais_cmp_shredder': 'datashredder',\n\t'ais_cmp_smc': 'smc',\n\t'ais_cmp_snx': 'sandbox',\n\t'ais_cmp_ng': 'NG',\n\t'ais_cmp_swhealth': 'softwarehealth',\n\t'ais_cmp_webrep': 'WebRep',\n\t'ais_cmp_hds': 'network',\n\t'ais_cmp_pwdman': 'passwords',\n\t'ais_cmp_secdns': 'secureDNS',\n\t'ais_cmp_gamingmode': 'gaming',\n\t'vps_boot32': 'boottime'\n};\n\nvar STANDALONES_MAP = {\n\t'ais_cmp_cleanup': 'cleanupPp',\n\t'ais_cmp_pap': 'pap',\n\t'ais_cmp_pwdman': 'pwdman',\n\t'ais_cmp_secureline': 'secureline'\n};\n\n// features which can have the premium license\nvar PREMIUM_FEATURES = ['cleanup', 'passwords', 'secureline'];\n\nvar FEATURE_IDS = {};\nfor (var key in FEATURES_MAP) {\n\tFEATURE_IDS[FEATURES_MAP[key]] = key;\n}\n\nexports.FEATURES_MAP = FEATURES_MAP;\nexports.STANDALONES_MAP = STANDALONES_MAP;\nexports.PREMIUM_FEATURES = PREMIUM_FEATURES;\nexports.FEATURE_IDS = FEATURE_IDS;\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nitro-ui-lib-productModel/libs/consts.js\n// module id = 136\n// module chunks = 0\n//# sourceURL=webpack:///./~/nitro-ui-lib-productModel/libs/consts.js?")},137:function(module,exports,__webpack_require__){eval('\'use strict\';\n\nObject.defineProperty(exports, "__esModule", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _eventemitter = __webpack_require__(138);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * EventEmitter is just a small extension of EventEmitter2 (NPM lib).\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * It extends the on function so that it returns the off function.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * And it also adjusts the off function.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\nvar EventEmitter = function (_EventEmitter) {\n\t_inherits(EventEmitter, _EventEmitter);\n\n\t/**\n  * Pass options to constructor\n  * @param  {Object} options See EventEmitter2 options https://github.com/asyncly/EventEmitter2\n  */\n\tfunction EventEmitter(options) {\n\t\t_classCallCheck(this, EventEmitter);\n\n\t\treturn _possibleConstructorReturn(this, (EventEmitter.__proto__ || Object.getPrototypeOf(EventEmitter)).call(this, options));\n\t}\n\n\t/**\n  * defaultMaxListeners\n  * @param  {String}   event    Event to be observed\n  * @param  {Function} callback Callback to be invoked when event is emitted\n  * @return {Function}          prebuilt off() function\n  */\n\n\n\t_createClass(EventEmitter, [{\n\t\tkey: \'on\',\n\t\tvalue: function on(event, callback) {\n\t\t\tvar _this2 = this;\n\n\t\t\t_eventemitter.EventEmitter2.prototype.on.call(this, event, callback);\n\n\t\t\t// return function the auto removes this observer\n\t\t\treturn function () {\n\t\t\t\t_this2.off(event, callback);\n\t\t\t};\n\t\t}\n\n\t\t/**\n   * Alias for removeListener and removeAllListeners\n   * @param  {String}   event    [description]\n   * @param  {Function} callback [description]\n   * @return {[type]}            [description]\n   */\n\n\t}, {\n\t\tkey: \'off\',\n\t\tvalue: function off(event, callback) {\n\t\t\tif (callback == undefined) {\n\t\t\t\tthis.removeAllListeners(event);\n\t\t\t} else {\n\t\t\t\tthis.removeListener(event, callback);\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn EventEmitter;\n}(_eventemitter.EventEmitter2);\n\nexports.default = EventEmitter;\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nitro-ui-lib-eventEmitter/libs/index.js\n// module id = 137\n// module chunks = 0\n//# sourceURL=webpack:///./~/nitro-ui-lib-eventEmitter/libs/index.js?')},138:function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process) {/*!\r\n * EventEmitter2\r\n * https://github.com/hij1nx/EventEmitter2\r\n *\r\n * Copyright (c) 2013 hij1nx\r\n * Licensed under the MIT license.\r\n */\r\n;!function(undefined) {\r\n\r\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\r\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\r\n  };\r\n  var defaultMaxListeners = 10;\r\n\r\n  function init() {\r\n    this._events = {};\r\n    if (this._conf) {\r\n      configure.call(this, this._conf);\r\n    }\r\n  }\r\n\r\n  function configure(conf) {\r\n    if (conf) {\r\n      this._conf = conf;\r\n\r\n      conf.delimiter && (this.delimiter = conf.delimiter);\r\n      this._maxListeners = conf.maxListeners !== undefined ? conf.maxListeners : defaultMaxListeners;\r\n\r\n      conf.wildcard && (this.wildcard = conf.wildcard);\r\n      conf.newListener && (this.newListener = conf.newListener);\r\n      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\r\n\r\n      if (this.wildcard) {\r\n        this.listenerTree = {};\r\n      }\r\n    } else {\r\n      this._maxListeners = defaultMaxListeners;\r\n    }\r\n  }\r\n\r\n  function logPossibleMemoryLeak(count, eventName) {\r\n    var errorMsg = '(node) warning: possible EventEmitter memory ' +\r\n        'leak detected. ' + count + ' listeners added. ' +\r\n        'Use emitter.setMaxListeners() to increase limit.';\r\n\r\n    if(this.verboseMemoryLeak){\r\n      errorMsg += ' Event name: ' + eventName + '.';\r\n    }\r\n\r\n    if(typeof process !== 'undefined' && process.emitWarning){\r\n      var e = new Error(errorMsg);\r\n      e.name = 'MaxListenersExceededWarning';\r\n      e.emitter = this;\r\n      e.count = count;\r\n      process.emitWarning(e);\r\n    } else {\r\n      console.error(errorMsg);\r\n\r\n      if (console.trace){\r\n        console.trace();\r\n      }\r\n    }\r\n  }\r\n\r\n  function EventEmitter(conf) {\r\n    this._events = {};\r\n    this.newListener = false;\r\n    this.verboseMemoryLeak = false;\r\n    configure.call(this, conf);\r\n  }\r\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\r\n\r\n  //\r\n  // Attention, function return type now is array, always !\r\n  // It has zero elements if no any matches found and one or more\r\n  // elements (leafs) if there are matches\r\n  //\r\n  function searchListenerTree(handlers, type, tree, i) {\r\n    if (!tree) {\r\n      return [];\r\n    }\r\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\r\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\r\n    if (i === typeLength && tree._listeners) {\r\n      //\r\n      // If at the end of the event(s) list and the tree has listeners\r\n      // invoke those listeners.\r\n      //\r\n      if (typeof tree._listeners === 'function') {\r\n        handlers && handlers.push(tree._listeners);\r\n        return [tree];\r\n      } else {\r\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\r\n          handlers && handlers.push(tree._listeners[leaf]);\r\n        }\r\n        return [tree];\r\n      }\r\n    }\r\n\r\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\r\n      //\r\n      // If the event emitted is '*' at this part\r\n      // or there is a concrete match at this patch\r\n      //\r\n      if (currentType === '*') {\r\n        for (branch in tree) {\r\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\r\n          }\r\n        }\r\n        return listeners;\r\n      } else if(currentType === '**') {\r\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\r\n        if(endReached && tree._listeners) {\r\n          // The next element has a _listeners, add it to the handlers.\r\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\r\n        }\r\n\r\n        for (branch in tree) {\r\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n            if(branch === '*' || branch === '**') {\r\n              if(tree[branch]._listeners && !endReached) {\r\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\r\n              }\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n            } else if(branch === nextType) {\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\r\n            } else {\r\n              // No match on this one, shift into the tree but not in the type array.\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n            }\r\n          }\r\n        }\r\n        return listeners;\r\n      }\r\n\r\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\r\n    }\r\n\r\n    xTree = tree['*'];\r\n    if (xTree) {\r\n      //\r\n      // If the listener tree will allow any match for this part,\r\n      // then recursively explore all branches of the tree\r\n      //\r\n      searchListenerTree(handlers, type, xTree, i+1);\r\n    }\r\n\r\n    xxTree = tree['**'];\r\n    if(xxTree) {\r\n      if(i < typeLength) {\r\n        if(xxTree._listeners) {\r\n          // If we have a listener on a '**', it will catch all, so add its handler.\r\n          searchListenerTree(handlers, type, xxTree, typeLength);\r\n        }\r\n\r\n        // Build arrays of matching next branches and others.\r\n        for(branch in xxTree) {\r\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\r\n            if(branch === nextType) {\r\n              // We know the next element will match, so jump twice.\r\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\r\n            } else if(branch === currentType) {\r\n              // Current node matches, move into the tree.\r\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\r\n            } else {\r\n              isolatedBranch = {};\r\n              isolatedBranch[branch] = xxTree[branch];\r\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\r\n            }\r\n          }\r\n        }\r\n      } else if(xxTree._listeners) {\r\n        // We have reached the end and still on a '**'\r\n        searchListenerTree(handlers, type, xxTree, typeLength);\r\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\r\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\r\n      }\r\n    }\r\n\r\n    return listeners;\r\n  }\r\n\r\n  function growListenerTree(type, listener) {\r\n\r\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n\r\n    //\r\n    // Looks for two consecutive '**', if so, don't add the event at all.\r\n    //\r\n    for(var i = 0, len = type.length; i+1 < len; i++) {\r\n      if(type[i] === '**' && type[i+1] === '**') {\r\n        return;\r\n      }\r\n    }\r\n\r\n    var tree = this.listenerTree;\r\n    var name = type.shift();\r\n\r\n    while (name !== undefined) {\r\n\r\n      if (!tree[name]) {\r\n        tree[name] = {};\r\n      }\r\n\r\n      tree = tree[name];\r\n\r\n      if (type.length === 0) {\r\n\r\n        if (!tree._listeners) {\r\n          tree._listeners = listener;\r\n        }\r\n        else {\r\n          if (typeof tree._listeners === 'function') {\r\n            tree._listeners = [tree._listeners];\r\n          }\r\n\r\n          tree._listeners.push(listener);\r\n\r\n          if (\r\n            !tree._listeners.warned &&\r\n            this._maxListeners > 0 &&\r\n            tree._listeners.length > this._maxListeners\r\n          ) {\r\n            tree._listeners.warned = true;\r\n            logPossibleMemoryLeak.call(this, tree._listeners.length, name);\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      name = type.shift();\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // By default EventEmitters will print a warning if more than\r\n  // 10 listeners are added to it. This is a useful default which\r\n  // helps finding memory leaks.\r\n  //\r\n  // Obviously not all Emitters should be limited to 10. This function allows\r\n  // that to be increased. Set to zero for unlimited.\r\n\r\n  EventEmitter.prototype.delimiter = '.';\r\n\r\n  EventEmitter.prototype.setMaxListeners = function(n) {\r\n    if (n !== undefined) {\r\n      this._maxListeners = n;\r\n      if (!this._conf) this._conf = {};\r\n      this._conf.maxListeners = n;\r\n    }\r\n  };\r\n\r\n  EventEmitter.prototype.event = '';\r\n\r\n\r\n  EventEmitter.prototype.once = function(event, fn) {\r\n    return this._once(event, fn, false);\r\n  };\r\n\r\n  EventEmitter.prototype.prependOnceListener = function(event, fn) {\r\n    return this._once(event, fn, true);\r\n  };\r\n\r\n  EventEmitter.prototype._once = function(event, fn, prepend) {\r\n    this._many(event, 1, fn, prepend);\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.many = function(event, ttl, fn) {\r\n    return this._many(event, ttl, fn, false);\r\n  }\r\n\r\n  EventEmitter.prototype.prependMany = function(event, ttl, fn) {\r\n    return this._many(event, ttl, fn, true);\r\n  }\r\n\r\n  EventEmitter.prototype._many = function(event, ttl, fn, prepend) {\r\n    var self = this;\r\n\r\n    if (typeof fn !== 'function') {\r\n      throw new Error('many only accepts instances of Function');\r\n    }\r\n\r\n    function listener() {\r\n      if (--ttl === 0) {\r\n        self.off(event, listener);\r\n      }\r\n      return fn.apply(this, arguments);\r\n    }\r\n\r\n    listener._origin = fn;\r\n\r\n    this._on(event, listener, prepend);\r\n\r\n    return self;\r\n  };\r\n\r\n  EventEmitter.prototype.emit = function() {\r\n\r\n    this._events || init.call(this);\r\n\r\n    var type = arguments[0];\r\n\r\n    if (type === 'newListener' && !this.newListener) {\r\n      if (!this._events.newListener) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    var al = arguments.length;\r\n    var args,l,i,j;\r\n    var handler;\r\n\r\n    if (this._all && this._all.length) {\r\n      handler = this._all.slice();\r\n      if (al > 3) {\r\n        args = new Array(al);\r\n        for (j = 0; j < al; j++) args[j] = arguments[j];\r\n      }\r\n\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler[i].call(this, type);\r\n          break;\r\n        case 2:\r\n          handler[i].call(this, type, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler[i].call(this, type, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          handler[i].apply(this, args);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      handler = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n    } else {\r\n      handler = this._events[type];\r\n      if (typeof handler === 'function') {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler.call(this);\r\n          break;\r\n        case 2:\r\n          handler.call(this, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler.call(this, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          args = new Array(al - 1);\r\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n          handler.apply(this, args);\r\n        }\r\n        return true;\r\n      } else if (handler) {\r\n        // need to make copy of handlers because list can change in the middle\r\n        // of emit call\r\n        handler = handler.slice();\r\n      }\r\n    }\r\n\r\n    if (handler && handler.length) {\r\n      if (al > 3) {\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n      }\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler[i].call(this);\r\n          break;\r\n        case 2:\r\n          handler[i].call(this, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler[i].call(this, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          handler[i].apply(this, args);\r\n        }\r\n      }\r\n      return true;\r\n    } else if (!this._all && type === 'error') {\r\n      if (arguments[1] instanceof Error) {\r\n        throw arguments[1]; // Unhandled 'error' event\r\n      } else {\r\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\r\n      }\r\n      return false;\r\n    }\r\n\r\n    return !!this._all;\r\n  };\r\n\r\n  EventEmitter.prototype.emitAsync = function() {\r\n\r\n    this._events || init.call(this);\r\n\r\n    var type = arguments[0];\r\n\r\n    if (type === 'newListener' && !this.newListener) {\r\n        if (!this._events.newListener) { return Promise.resolve([false]); }\r\n    }\r\n\r\n    var promises= [];\r\n\r\n    var al = arguments.length;\r\n    var args,l,i,j;\r\n    var handler;\r\n\r\n    if (this._all) {\r\n      if (al > 3) {\r\n        args = new Array(al);\r\n        for (j = 1; j < al; j++) args[j] = arguments[j];\r\n      }\r\n      for (i = 0, l = this._all.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          promises.push(this._all[i].call(this, type));\r\n          break;\r\n        case 2:\r\n          promises.push(this._all[i].call(this, type, arguments[1]));\r\n          break;\r\n        case 3:\r\n          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\r\n          break;\r\n        default:\r\n          promises.push(this._all[i].apply(this, args));\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      handler = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n    } else {\r\n      handler = this._events[type];\r\n    }\r\n\r\n    if (typeof handler === 'function') {\r\n      this.event = type;\r\n      switch (al) {\r\n      case 1:\r\n        promises.push(handler.call(this));\r\n        break;\r\n      case 2:\r\n        promises.push(handler.call(this, arguments[1]));\r\n        break;\r\n      case 3:\r\n        promises.push(handler.call(this, arguments[1], arguments[2]));\r\n        break;\r\n      default:\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n        promises.push(handler.apply(this, args));\r\n      }\r\n    } else if (handler && handler.length) {\r\n      handler = handler.slice();\r\n      if (al > 3) {\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n      }\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          promises.push(handler[i].call(this));\r\n          break;\r\n        case 2:\r\n          promises.push(handler[i].call(this, arguments[1]));\r\n          break;\r\n        case 3:\r\n          promises.push(handler[i].call(this, arguments[1], arguments[2]));\r\n          break;\r\n        default:\r\n          promises.push(handler[i].apply(this, args));\r\n        }\r\n      }\r\n    } else if (!this._all && type === 'error') {\r\n      if (arguments[1] instanceof Error) {\r\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\r\n      } else {\r\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\r\n      }\r\n    }\r\n\r\n    return Promise.all(promises);\r\n  };\r\n\r\n  EventEmitter.prototype.on = function(type, listener) {\r\n    return this._on(type, listener, false);\r\n  };\r\n\r\n  EventEmitter.prototype.prependListener = function(type, listener) {\r\n    return this._on(type, listener, true);\r\n  };\r\n\r\n  EventEmitter.prototype.onAny = function(fn) {\r\n    return this._onAny(fn, false);\r\n  };\r\n\r\n  EventEmitter.prototype.prependAny = function(fn) {\r\n    return this._onAny(fn, true);\r\n  };\r\n\r\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\r\n\r\n  EventEmitter.prototype._onAny = function(fn, prepend){\r\n    if (typeof fn !== 'function') {\r\n      throw new Error('onAny only accepts instances of Function');\r\n    }\r\n\r\n    if (!this._all) {\r\n      this._all = [];\r\n    }\r\n\r\n    // Add the function to the event listener collection.\r\n    if(prepend){\r\n      this._all.unshift(fn);\r\n    }else{\r\n      this._all.push(fn);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  EventEmitter.prototype._on = function(type, listener, prepend) {\r\n    if (typeof type === 'function') {\r\n      this._onAny(type, listener);\r\n      return this;\r\n    }\r\n\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('on only accepts instances of Function');\r\n    }\r\n    this._events || init.call(this);\r\n\r\n    // To avoid recursion in the case that type == \"newListeners\"! Before\r\n    // adding it to the listeners, first emit \"newListeners\".\r\n    this.emit('newListener', type, listener);\r\n\r\n    if (this.wildcard) {\r\n      growListenerTree.call(this, type, listener);\r\n      return this;\r\n    }\r\n\r\n    if (!this._events[type]) {\r\n      // Optimize the case of one listener. Don't need the extra array object.\r\n      this._events[type] = listener;\r\n    }\r\n    else {\r\n      if (typeof this._events[type] === 'function') {\r\n        // Change to array.\r\n        this._events[type] = [this._events[type]];\r\n      }\r\n\r\n      // If we've already got an array, just add\r\n      if(prepend){\r\n        this._events[type].unshift(listener);\r\n      }else{\r\n        this._events[type].push(listener);\r\n      }\r\n\r\n      // Check for listener leak\r\n      if (\r\n        !this._events[type].warned &&\r\n        this._maxListeners > 0 &&\r\n        this._events[type].length > this._maxListeners\r\n      ) {\r\n        this._events[type].warned = true;\r\n        logPossibleMemoryLeak.call(this, this._events[type].length, type);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  EventEmitter.prototype.off = function(type, listener) {\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('removeListener only takes instances of Function');\r\n    }\r\n\r\n    var handlers,leafs=[];\r\n\r\n    if(this.wildcard) {\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n    }\r\n    else {\r\n      // does not use listeners(), so no side effect of creating _events[type]\r\n      if (!this._events[type]) return this;\r\n      handlers = this._events[type];\r\n      leafs.push({_listeners:handlers});\r\n    }\r\n\r\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n      var leaf = leafs[iLeaf];\r\n      handlers = leaf._listeners;\r\n      if (isArray(handlers)) {\r\n\r\n        var position = -1;\r\n\r\n        for (var i = 0, length = handlers.length; i < length; i++) {\r\n          if (handlers[i] === listener ||\r\n            (handlers[i].listener && handlers[i].listener === listener) ||\r\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\r\n            position = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (position < 0) {\r\n          continue;\r\n        }\r\n\r\n        if(this.wildcard) {\r\n          leaf._listeners.splice(position, 1);\r\n        }\r\n        else {\r\n          this._events[type].splice(position, 1);\r\n        }\r\n\r\n        if (handlers.length === 0) {\r\n          if(this.wildcard) {\r\n            delete leaf._listeners;\r\n          }\r\n          else {\r\n            delete this._events[type];\r\n          }\r\n        }\r\n\r\n        this.emit(\"removeListener\", type, listener);\r\n\r\n        return this;\r\n      }\r\n      else if (handlers === listener ||\r\n        (handlers.listener && handlers.listener === listener) ||\r\n        (handlers._origin && handlers._origin === listener)) {\r\n        if(this.wildcard) {\r\n          delete leaf._listeners;\r\n        }\r\n        else {\r\n          delete this._events[type];\r\n        }\r\n\r\n        this.emit(\"removeListener\", type, listener);\r\n      }\r\n    }\r\n\r\n    function recursivelyGarbageCollect(root) {\r\n      if (root === undefined) {\r\n        return;\r\n      }\r\n      var keys = Object.keys(root);\r\n      for (var i in keys) {\r\n        var key = keys[i];\r\n        var obj = root[key];\r\n        if ((obj instanceof Function) || (typeof obj !== \"object\") || (obj === null))\r\n          continue;\r\n        if (Object.keys(obj).length > 0) {\r\n          recursivelyGarbageCollect(root[key]);\r\n        }\r\n        if (Object.keys(obj).length === 0) {\r\n          delete root[key];\r\n        }\r\n      }\r\n    }\r\n    recursivelyGarbageCollect(this.listenerTree);\r\n\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.offAny = function(fn) {\r\n    var i = 0, l = 0, fns;\r\n    if (fn && this._all && this._all.length > 0) {\r\n      fns = this._all;\r\n      for(i = 0, l = fns.length; i < l; i++) {\r\n        if(fn === fns[i]) {\r\n          fns.splice(i, 1);\r\n          this.emit(\"removeListenerAny\", fn);\r\n          return this;\r\n        }\r\n      }\r\n    } else {\r\n      fns = this._all;\r\n      for(i = 0, l = fns.length; i < l; i++)\r\n        this.emit(\"removeListenerAny\", fns[i]);\r\n      this._all = [];\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\r\n\r\n  EventEmitter.prototype.removeAllListeners = function(type) {\r\n    if (arguments.length === 0) {\r\n      !this._events || init.call(this);\r\n      return this;\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n\r\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n        var leaf = leafs[iLeaf];\r\n        leaf._listeners = null;\r\n      }\r\n    }\r\n    else if (this._events) {\r\n      this._events[type] = null;\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.listeners = function(type) {\r\n    if (this.wildcard) {\r\n      var handlers = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\r\n      return handlers;\r\n    }\r\n\r\n    this._events || init.call(this);\r\n\r\n    if (!this._events[type]) this._events[type] = [];\r\n    if (!isArray(this._events[type])) {\r\n      this._events[type] = [this._events[type]];\r\n    }\r\n    return this._events[type];\r\n  };\r\n\r\n  EventEmitter.prototype.eventNames = function(){\r\n    return Object.keys(this._events);\r\n  }\r\n\r\n  EventEmitter.prototype.listenerCount = function(type) {\r\n    return this.listeners(type).length;\r\n  };\r\n\r\n  EventEmitter.prototype.listenersAny = function() {\r\n\r\n    if(this._all) {\r\n      return this._all;\r\n    }\r\n    else {\r\n      return [];\r\n    }\r\n\r\n  };\r\n\r\n  if (true) {\r\n     // AMD. Register as an anonymous module.\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\r\n      return EventEmitter;\r\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n  } else if (typeof exports === 'object') {\r\n    // CommonJS\r\n    module.exports = EventEmitter;\r\n  }\r\n  else {\r\n    // Browser global.\r\n    window.EventEmitter2 = EventEmitter;\r\n  }\r\n}();\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nitro-ui-lib-eventEmitter/~/eventemitter2/lib/eventemitter2.js\n// module id = 138\n// module chunks = 0\n//# sourceURL=webpack:///./~/nitro-ui-lib-eventEmitter/~/eventemitter2/lib/eventemitter2.js?");
},139:function(module,exports){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction isEqual(a, b) {\n\tvar p = void 0,\n\t    t = void 0;\n\n\tif (typeof a === 'undefined' && typeof b !== 'undefined') {\n\t\treturn false;\n\t}\n\n\tif (typeof a !== 'undefined' && typeof b === 'undefined') {\n\t\treturn false;\n\t}\n\n\tif (a === null && b !== null || a !== null && b === null) {\n\t\treturn false;\n\t}\n\n\tif (typeof a === 'string' || typeof a === 'number' || typeof a === 'boolean') {\n\t\treturn a === b;\n\t} else {\n\t\tfor (p in a) {\n\t\t\tif (typeof b[p] === 'undefined') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (b[p] && !a[p]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tt = _typeof(a[p]);\n\t\t\tif (t === 'object' && !isEqual(a[p], b[p])) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (t === 'function' && (typeof b[p] === 'undefined' || a[p].toString() !== b[p].toString())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (t !== 'object' && t !== 'function' && a[p] !== b[p]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (p in b) {\n\t\t\tif (typeof a[p] === 'undefined') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nexports.isEqual = isEqual;\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nitro-ui-lib-productModel/libs/utils.js\n// module id = 139\n// module chunks = 0\n//# sourceURL=webpack:///./~/nitro-ui-lib-productModel/libs/utils.js?")}});